
---------------------------------------- Primero 1 ---------------------------------------------------------------
Perfecto, este es el corazÃ³n de cualquier e-commerce/ERP serio.
Te voy a dar una arquitectura de base de datos probada, usada en sistemas de logÃ­stica, ERP y e-commerce multidepÃ³sito, pensada para Laravel + Eloquent.

ğŸ‘‰ Objetivo:

    Multi-almacÃ©n (multi storage / depÃ³sitos)

    Stock confiable

    Historial completo de movimientos

    Ventas desacopladas del stock

    Escalable y auditable

ğŸ§  Principio clave (MUY IMPORTANTE)

    El stock NO se guarda â€œmoviendo nÃºmerosâ€
    El stock se CALCULA a partir de los movimientos

El stock actual es una vista (o tabla cacheada),
pero la verdad estÃ¡ en stock_movements.
ğŸ§± Modelo de datos general

products
storages (warehouses)
stock_levels        (opcional / cache)
stock_movements

orders (ventas)
order_items

ğŸ§± 1) Products

products
--------
id
sku
name
type            -- simple | variant | service
manage_stock    -- bool
timestamps

ğŸ“Œ Nota:

    Servicios o digitales â†’ manage_stock = false

ğŸ§± 2) Storages (depÃ³sitos / sucursales)

storages
--------
id
name
code            -- WH01, LOCAL01
type            -- warehouse | store | virtual
address
timestamps

Ej:

    DepÃ³sito central

    Sucursal fÃ­sica

    Mercado Libre Full (virtual)

ğŸ§± 3) Stock Levels (opcional pero recomendado)

âš ï¸ NO es la fuente de verdad
âš¡ Es cache para consultas rÃ¡pidas

stock_levels
------------
product_id
storage_id
quantity
updated_at

PRIMARY KEY (product_id, storage_id)

ğŸ“Œ Se recalcula automÃ¡ticamente desde stock_movements.
ğŸ§± 4) Stock Movements (TABLA CLAVE)

stock_movements
---------------
id
product_id
storage_id
quantity        -- + o -
movement_type  -- IN | OUT | ADJUST | TRANSFER
source_type    -- purchase | sale | return | adjustment | transfer
source_id      -- id de la orden, compra, etc
notes
created_at

Ejemplos:
Tipo	Cantidad
Compra	+50
Venta	-2
Ajuste inventario	-1
Transferencia	-10 / +10
ğŸ§± 5) Transferencias entre depÃ³sitos

Las transferencias son 2 movimientos:

- OUT â†’ storage A
+ IN  â†’ storage B

Ambos con el mismo source_id.
ğŸ§± 6) Ventas (Orders)

orders
------
id
user_id
status        -- pending | paid | shipped | canceled
total
created_at

ğŸ§± 7) Items de la venta

order_items
-----------
id
order_id
product_id
storage_id        -- de dÃ³nde se despacha
quantity
price
subtotal

ğŸ“Œ El storage_id es CLAVE para multi-depÃ³sito.
ğŸ”— Relaciones Eloquent
Product

public function stockMovements()
{
    return $this->hasMany(StockMovement::class);
}

public function stockLevels()
{
    return $this->hasMany(StockLevel::class);
}

Storage

public function stockMovements()
{
    return $this->hasMany(StockMovement::class);
}

ğŸ§® CÃ³mo calcular stock real (sin cache)

SELECT SUM(quantity)
FROM stock_movements
WHERE product_id = ?
AND storage_id = ?

âš¡ CÃ³mo actualizar stock_levels (cache)

Cada vez que insertÃ¡s un movimiento:

StockLevel::updateOrCreate(
    [
        'product_id' => $productId,
        'storage_id' => $storageId
    ],
    [
        'quantity' => DB::raw('quantity + ' . $movementQty)
    ]
);

ğŸ”¥ Flujo completo de una venta

1ï¸âƒ£ Cliente compra
2ï¸âƒ£ Se crea order
3ï¸âƒ£ Se crean order_items
4ï¸âƒ£ Se crean stock_movements (OUT)
5ï¸âƒ£ Se actualiza stock_levels

âœ” Auditable
âœ” Reversible
âœ” Sin inconsistencias
ğŸ›¡ï¸ Ventajas de esta arquitectura

âœ… Soporta multi-depÃ³sito real
âœ… Historial completo (auditorÃ­a)
âœ… FÃ¡cil rollback (cancelar venta = movimiento inverso)
âœ… Compatible con Mercado Libre, Full, envÃ­os externos
âœ… Escala a miles de productos y movimientos
âœ… Usada por Odoo, SAP, Shopify, VTEX, etc.
ğŸ“Œ Extensiones habituales (si querÃ©s)

Puedo ampliarte esto con:
    ğŸ”¸ Reservas de stock (pending orders)
    ğŸ”¸ Lotes y vencimientos
    ğŸ”¸ Series / IMEI
    ğŸ”¸ Stock mÃ­nimo por depÃ³sito
    ğŸ”¸ IntegraciÃ³n con Mercado Libre Full
    ğŸ”¸ Eventos + colas (queues)
    ğŸ”¸ Soft delete contable
----------------------------------------------------------------------------------------------------------------------

-------------------------  SEGUNDO 2  ---------------------------------------------------------------------
En Laravel (y en general en cualquier arquitectura limpia) sÃ­ es mÃ¡s eficiente y mÃ¡s mantenible separar los datos de login de los datos personales del usuario.
Es una prÃ¡ctica comÃºn y recomendada.
âœ… La mejor prÃ¡ctica: separar users y profiles
Por quÃ© separar las tablas

    Seguridad
    Los datos sensibles de autenticaciÃ³n (email, password, remember_token, 2FA, etc.) deben estar aislados del resto de la informaciÃ³n.
    Si algÃºn dÃ­a compartÃ­s la tabla de perfiles con un sistema externo, no exponÃ©s datos crÃ­ticos.

    Escalabilidad y limpieza
    La tabla users queda pequeÃ±a y estable.
    La tabla profiles puede crecer con muchos campos adicionales sin afectar el login ni tocar nada de autenticaciÃ³n.

    MÃ³dulos independientes
    PodÃ©s tener mÃ³dulos que acceden al perfil, pero no deben ver el email/password.
    Ejemplo: un mÃ³dulo de RRHH, CRM, o estadÃ­sticas.

    Rendimiento
    La tabla users se consulta todo el tiempo (middleware, autenticaciÃ³n, tokens, login, etc.) â†’ cuanto mÃ¡s liviana mejor.
    El perfil solo se consulta cuando realmente hace falta.

    Mejor organizaciÃ³n del modelo Eloquent
    Evita modelos gigantes con decenas de columnas no relacionadas entre sÃ­.

ğŸ§± Estructura recomendada de BD
Tabla users

SÃ³lo lo necesario para login/autenticaciÃ³n:
Campo	Uso
id	PK
email	login
password	login
email_verified_at	verificaciÃ³n
remember_token	sesiones
created_at / updated_at	timestamps
Tabla profiles

Datos personales del usuario:
Campo	Ejemplo
id	PK
user_id	FK a users
nombre	"Juan"
apellido	"GonzÃ¡lez"
telefono	"+54 ..."
direccion	"...
avatar	"/img/user/..."
fecha_nacimiento	"1982-05-10"
...	cualquier extra
ğŸ”— RelaciÃ³n Eloquent
User.php

class User extends Authenticatable
{
    public function profile()
    {
        return $this->hasOne(Profile::class);
    }
}

Profile.php

class Profile extends Model
{
    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

ğŸ“Œ Â¿CuÃ¡ndo NO hace falta separar?

Si tu aplicaciÃ³n es muy simple, por ejemplo:

    un blog personal,

    o un panel pequeÃ±o donde solo vos usÃ¡s el sistema.

En esos casos no pasa nada si mezclÃ¡s todo en users.
Pero en cuanto tu sistema crece un poco â†’ separar es mucho mejor.
ğŸ¯ ConclusiÃ³n

SÃ­:
âœ” Es mejor prÃ¡ctica separar User (login) y Profile (datos personales)
âœ” Te da seguridad, claridad, desacoplamiento, rendimiento y escalabilidad
âœ” Laravel Eloquent lo maneja muy bien con hasOne

Si querÃ©s te puedo mostrar:

âœ… Migraciones completas
âœ… Modelos completos
âœ… Seeders
âœ… CÃ³mo cargar el perfil automÃ¡ticamente despuÃ©s del registro
Solo pedÃ­melo.
TÃº dijiste:
y si ademÃ¡s tengo roles, como debo hacer esta relacion con user
ChatGPT Plus

La relaciÃ³n entre Users y Roles depende del tipo de sistema que quieras construir, pero en el 99% de los proyectos modernos se usa una relaciÃ³n Many-to-Many.

Es decir:

    Un usuario puede tener uno o varios roles

    Un rol puede pertenecer a muchos usuarios

Esto se maneja con una tabla pivote: role_user (o users_roles).
âœ… DiseÃ±o recomendado para roles
ğŸ§± Tablas
Tabla roles

id
name
slug      // admin, editor, vendedor, cliente
description
created_at, updated_at

Tabla pivote role_user

user_id
role_id

No necesita ID propio.
ğŸ”— Relaciones Eloquent
User.php

public function roles()
{
    return $this->belongsToMany(Role::class);
}

Role.php

public function users()
{
    return $this->belongsToMany(User::class);
}

ğŸ¯ Â¿Por quÃ© es mejor Many-to-Many?

Porque permite cosas como:

    un usuario puede ser Admin + Editor

    un usuario puede cambiar de rol sin cambiar arquitectura

    podÃ©s agregar roles nuevos sin tocar la tabla users

    se pueden agregar permisos por rol mÃ¡s adelante

Es la misma arquitectura que usan:

    Spatie Permissions

    Laravel Permission Packages

    Cualquier RBAC (Role Based Access Control) moderno

ğŸ§© Â¿Y cÃ³mo se relaciona con el Profile?

AsÃ­ queda todo:

users
   |
   |-- hasOne --> profiles
   |
   |-- belongsToMany --> roles

Es decir:

    User tiene un Profile

    User tiene uno o varios Roles

El Profile NO debe tener relaciÃ³n con los roles, porque es solo datos personales.
ğŸ§ª Ejemplo prÃ¡ctico de asignar roles

$user = User::find(1);

// asignar un rol
$user->roles()->attach(2);

// quitar un rol
$user->roles()->detach(3);

// sincronizar roles
$user->roles()->sync([1, 4]);  // deja solo esos roles

ğŸ§  Â¿QuerÃ©s usar permisos tambiÃ©n?

Si querÃ©s un sistema completo tipo ACL (Roles + Permisos), te puedo diseÃ±ar este esquema:

    Tabla roles

    Tabla permissions

    pivotes: role_permission, user_role

Y con las relaciones listas para usar en Laravel.

PedÃ­melo y te lo preparo.
TÃº dijiste:
pero cuantas consultas puedo generar a la tabla roles de esta forma?
ChatGPT Plus

Buena pregunta, porque la cantidad de consultas es clave para rendimiento.

La respuesta corta:

ğŸ‘‰ Si usÃ¡s la relaciÃ³n many-to-many normal, las consultas son pocas y totalmente controlables.
ğŸ‘‰ Y si usÃ¡s with() para eager loading, casi siempre vas a tener solo 1 o 2 consultas sin importar cuÃ¡ntos usuarios o roles haya.
âœ… Â¿CuÃ¡ntas consultas hace Eloquent a roles?
âœ” 1) Si cargÃ¡s un usuario y luego pedÃ­s sus roles (lazy loading)

$user = User::find(1);      // 1 consulta a users
$user->roles;               // 1 consulta a role_user + roles

Total:
2 consultas

siempre, independientemente de la cantidad de roles que tenga.
âœ” 2) Si cargÃ¡s varios usuarios sin eager loading (MAL):

$users = User::all();   // 1 consulta a users

foreach($users as $u) {
    $u->roles;          // 1 consulta por cada user â†’ N+1 problem
}

Ejemplo: 100 usuarios = 101 consultas

Esto es maloâ€¦ pero Laravel te da la soluciÃ³n:
ğŸš€ 3) Con eager loading (la forma correcta y Ã³ptima)

$users = User::with('roles')->get();

Eloquent harÃ¡:

    1 consulta â†’ tabla users

    1 consulta â†’ tabla pivote + roles

Total:
2 consultas sin importar si tenÃ©s 10, 100, 1000 o 20.000 usuarios

Esto es sÃºper eficiente.
ğŸ§  Â¿Por quÃ© solo 1 consulta para roles?

Laravel ejecuta:

SELECT * FROM roles
INNER JOIN role_user ON roles.id = role_user.role_id
WHERE user_id IN (lista de todos los usuarios cargados)

Eso trae todo de una vez.
ğŸï¸ 4) Consulta de roles para un solo usuario

Siempre serÃ¡ solo 1 consulta:

$user->roles;

Porque hace:

SELECT roles.*
FROM roles
JOIN role_user ON role_id = roles.id
WHERE user_id = X;

ğŸ›¡ï¸ ConclusiÃ³n sobre rendimiento

DiseÃ±o User â†” Role Many-to-Many es:

    Performante

    Escalable

    Usado por todos los sistemas RBAC

âœ Nunca vas a tener un problema de consultas si usÃ¡s EAGER LOADING (with()).
ğŸ“Œ Â¿QuerÃ©s que te modele un sistema completo RBAC (Roles + Permisos) con todas las relaciones y optimizaciones?

Te lo armo si querÃ©s.
TÃº dijiste:
si por favor
ChatGPT Plus

Perfecto. AcÃ¡ tenÃ©s un sistema RBAC completo, profesional, escalable y totalmente compatible con Laravel sin usar paquetes externos (aunque es compatible con Spatie si despuÃ©s querÃ©s).

Incluye:

    Estructura de BD

    Migraciones

    Modelos Eloquent

    Relaciones

    CÃ³mo asignar roles y permisos

    CÃ³mo consultar permisos de un usuario

    Middleware de autorizaciÃ³n

ğŸ§± 1. Estructura de Base de Datos (RBAC Completo)
Tabla roles

    id

    name

    slug

    description

Tabla permissions

    id

    name

    slug

    description

Tabla pivote role_user

    role_id

    user_id

Tabla pivote permission_role

    permission_id

    role_id

    Importante:
    Los permisos siempre se asignan al rol.
    Los usuarios obtienen permisos a travÃ©s de sus roles.

ğŸ“ 2. Migraciones
create_roles_table.php

Schema::create('roles', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('slug')->unique();
    $table->string('description')->nullable();
    $table->timestamps();
});

create_permissions_table.php

Schema::create('permissions', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('slug')->unique();
    $table->string('description')->nullable();
    $table->timestamps();
});

create_role_user_table.php

Schema::create('role_user', function (Blueprint $table) {
    $table->foreignId('role_id')->constrained()->cascadeOnDelete();
    $table->foreignId('user_id')->constrained()->cascadeOnDelete();
    $table->primary(['role_id', 'user_id']);
});

create_permission_role_table.php

Schema::create('permission_role', function (Blueprint $table) {
    $table->foreignId('permission_id')->constrained()->cascadeOnDelete();
    $table->foreignId('role_id')->constrained()->cascadeOnDelete();
    $table->primary(['permission_id', 'role_id']);
});

ğŸ“¦ 3. Modelos Eloquent
Role.php

class Role extends Model
{
    protected $fillable = ['name', 'slug', 'description'];

    public function permissions()
    {
        return $this->belongsToMany(Permission::class);
    }

    public function users()
    {
        return $this->belongsToMany(User::class);
    }
}

Permission.php

class Permission extends Model
{
    protected $fillable = ['name', 'slug', 'description'];

    public function roles()
    {
        return $this->belongsToMany(Role::class);
    }
}

User.php

class User extends Authenticatable
{
    public function roles()
    {
        return $this->belongsToMany(Role::class);
    }

    public function hasRole($slug)
    {
        return $this->roles->pluck('slug')->contains($slug);
    }

    public function hasPermission($slug)
    {
        return $this->roles
            ->flatMap->permissions
            ->pluck('slug')
            ->contains($slug);
    }
}

ğŸ”¥ 4. Asignar Roles y Permisos
Crear roles

Role::create([
    'name' => 'Administrador',
    'slug' => 'admin',
]);

Crear permisos

Permission::create([
    'name' => 'Crear usuarios',
    'slug' => 'users.create',
]);

Asignar permisos a roles

$role = Role::where('slug', 'admin')->first();
$role->permissions()->attach($permission_id);

Asignar roles a usuarios

$user = User::find(1);
$user->roles()->attach($role_id);

ğŸ” 5. CÃ³mo consultar roles y permisos
Ver si un usuario tiene un rol

if ($user->hasRole('admin')) {
    // ok
}

Ver si un usuario tiene un permiso

if ($user->hasPermission('users.create')) {
    // ok
}

ğŸ›¡ï¸ 6. Middleware de permisos
Generar middleware

php artisan make:middleware PermissionMiddleware

PermissionMiddleware.php

public function handle($request, Closure $next, $permission)
{
    if (!auth()->user()->hasPermission($permission)) {
        abort(403, 'No tienes permisos');
    }

    return $next($request);
}

Registrar middleware

En app/Http/Kernel.php:

'permission' => \App\Http\Middleware\PermissionMiddleware::class,

Usarlo en rutas:

Route::get('/admin', function () {
    return 'Panel Admin';
})->middleware('permission:admin.access');

âš¡ 7. OptimizaciÃ³n de consultas (IMPORTANTÃSIMO)

Cuando obtengas usuarios con roles y permisos:

$users = User::with('roles.permissions')->get();

Esto genera:

    1 consulta a users

    1 consulta a role_user + roles

    1 consulta a permission_role + permissions

TOTAL: 3 CONSULTAS
Aunque cargues 1.000 usuarios con 20 roles y 200 permisos.

MÃ¡ximo rendimiento.
ğŸ§  8. Â¿QuerÃ©s roles jerÃ¡rquicos, permisos directos al usuario, o un sistema multigrupo?

Puedo extenderte el sistema:

    ğŸ”¸ Roles heredados (Admin hereda Supervisor)

    ğŸ”¸ Permisos directos al usuario (como Spatie)

    ğŸ”¸ MÃ³dulos separados (ACL modular)

    ğŸ”¸ Cacheo completo con Redis

    ğŸ”¸ Seeders automÃ¡ticos

Si querÃ©s, decime quÃ© tipo de sistema vas a construir (ERP, e-commerce, multiempresa, SaaS, etc.) y te hago la arquitectura exacta.
TÃº dijiste:
detalla esto: public function hasRole($slug) { return $this->roles->pluck('slug')->contains($slug); } public function hasPermission($slug) { return $this->roles ->flatMap->permissions ->pluck('slug') ->contains($slug); }
ChatGPT Plus

AquÃ­ va el detalle completo, paso a paso, de cÃ³mo funcionan los mÃ©todos hasRole() y hasPermission(), quÃ© hace cada lÃ­nea y por quÃ© estÃ¡ diseÃ±ado asÃ­.
ğŸ§© 1. MÃ©todo hasRole()

public function hasRole($slug)
{
    return $this->roles->pluck('slug')->contains($slug);
}

Vamos lÃ­nea por lÃ­nea:
ğŸ”¥ $this->roles

    $this es el User.

    roles es la relaciÃ³n belongsToMany() ya cargada o que se carga al momento.

Devuelve una Collection de Role.

Ejemplo de lo que puede contener:

[
    (Role { id:1, slug:"admin", ... }),
    (Role { id:2, slug:"editor", ... }),
]

ğŸ”¥ ->pluck('slug')

Toma esa colecciÃ³n de objetos Role y extrae solo la columna slug.

Resultado:

[
    "admin",
    "editor"
]

Es mÃ¡s eficiente trabajar solo con strings en lugar de objetos completos.
ğŸ”¥ ->contains($slug)

Pregunta si el string que pasamos existe dentro del array.

Ejemplo:

$user->hasRole('admin'); // true
$user->hasRole('cliente'); // false

âœ… Resultado final

hasRole() devuelve true si el usuario posee ese rol, caso contrario devuelve false.
ğŸ§© 2. MÃ©todo hasPermission()

public function hasPermission($slug)
{
    return $this->roles
        ->flatMap->permissions
        ->pluck('slug')
        ->contains($slug);
}

Este mÃ©todo es mÃ¡s complejo porque:

    un usuario no tiene permisos directos,

    sino a travÃ©s de TODOS sus roles.

Ejemplo:

User:
  roles:
    - admin
        permissions: [users.create, users.delete, orders.manage]
    - editor
        permissions: [posts.create, posts.edit]

ğŸ”¥ Paso 1: $this->roles

Devuelve:

Collection([
    Role1,
    Role2,
])

ğŸ”¥ Paso 2: flatMap->permissions

AquÃ­ ocurre la magia.
Â¿QuÃ© hace flatMap?

    Ejecuta $role->permissions para cada rol.

    Aplana todo en una sola colecciÃ³n.

Ejemplo de resultado:

Collection([
    Permission { slug:"users.create" },
    Permission { slug:"users.delete" },
    Permission { slug:"orders.manage" },
    Permission { slug:"posts.create" },
    Permission { slug:"posts.edit" },
])

Sin flatMap obtendrÃ­as una colecciÃ³n de colecciones, lo cual es incÃ³modo.
ğŸ”¥ Paso 3: ->pluck('slug')

Extrae solo los slugs:

[
    "users.create",
    "users.delete",
    "orders.manage",
    "posts.create",
    "posts.edit"
]

ğŸ”¥ Paso 4: ->contains($slug)

Comprueba si el usuario tiene ese permiso:

$user->hasPermission('posts.edit');   // true
$user->hasPermission('users.read');   // false

ğŸ“Œ Â¿Por quÃ© funciona asÃ­?

Porque los permisos estÃ¡n en los roles, no en los usuarios:

User â†’ hasMany Roles â†’ hasMany Permissions

La funciÃ³n:

    reÃºne los permisos de todos sus roles

    los aplana en 1 sola lista

    busca el permiso

Super Ã³ptimo y claro.
ğŸ›¡ï¸ Â¿Es eficiente?

SÃ­, si usÃ¡s EAGER LOADING:

User::with('roles.permissions')->find($id);

Entonces hasRole() y hasPermission() no hacen consultas extra, solo trabajan en memoria.
â†’ Ultra rÃ¡pido.
ğŸ Â¿QuerÃ©s una versiÃ³n mÃ¡s poderosa con cachÃ© y autorizaciÃ³n avanzada?

Te puedo armar:

    hasAnyRole()

    hasAllRoles()

    hasAnyPermission()

    hasAllPermissions()

    Cache automÃ¡tico por usuario

    Cache por rol

    Directivas Blade @role y @permission

Solo decime.
TÃº dijiste:
ahora en mi aplicaciÃ³n laravel tengo Product, ya que la aplicacÃ³n es un e-commers, pero no solo publica los producto en la web propia, sino que tambien publica lo product en Mercado Libre, google merchent y meta. como seria mÃ¡s optimo guardar la informacÃ³n necesari del product en la DB, si en una sola table o en varias relacionadas
ChatGPT Plus

Excelente pregunta. Para un e-commerce multicanal (web propia, Mercado Libre, Google Merchant, Meta/Facebook Shop), NO es Ã³ptimo guardar toda la informaciÃ³n del producto en una Ãºnica tabla.
La arquitectura mÃ¡s eficiente y escalable es dividir la informaciÃ³n del producto en varias tablas relacionadas, siguiendo una estructura modular, normalizada y orientada a canales.

A continuaciÃ³n te doy la arquitectura ideal, explicando el por quÃ© y el cÃ³mo.
âœ… CONCLUSIÃ“N RÃPIDA

La mejor prÃ¡ctica es:
âœ” Tabla principal: products
âœ” Tablas secundarias por categorÃ­a de datos
âœ” Tablas especÃ­ficas por canal (Mercado Libre, Google, Meta)

AsÃ­ evitas una tabla gigante e inmanejable, manteniendo rendimiento y flexibilidad.

Vamos con el detalle.
ğŸ§± 1) Tabla principal products (datos comunes)

AquÃ­ guardÃ¡s SOLO lo que es comÃºn para todos los canales.

Ejemplo:

products
---------
id
sku
name
brand_id
category_id
price
sale_price
stock
status          // active, paused
description     // versiÃ³n corta si querÃ©s
...
timestamps

Datos que todas las plataformas necesitan.
ğŸ§± 2) Tabla product_details (descripciÃ³n extensa + imÃ¡genes)

Muchos e-commerce separan:

    descripciones largas

    caracterÃ­sticas tÃ©cnicas

    contenido HTML

    imÃ¡genes

Esto evita sobrecargar la tabla principal.

product_details
---------------
id
product_id (FK)
long_description
features (JSON)
specs (JSON)
images (JSON) o tabla aparte product_images

ğŸ§± 3) Tablas de atributos dinÃ¡micos (si tu catÃ¡logo es grande)

Ejemplo: TV, heladeras, notebooks, lavarropasâ€¦
Cada categorÃ­a tiene atributos distintos.

UsÃ¡s un sistema tipo:
attributes

id | name        | type
1  | color       | string
2  | potencia    | integer
3  | pulgadas    | integer

product_attribute_values

product_id | attribute_id | value

Esto lo usan Shopify, WooCommerce, Magento, Prestashop, Odoo, etc.
ğŸ§± 4) Tablas por canal (MUY IMPORTANTE)

Cada canal tiene requerimientos distintos, formatos distintos, IDs distintos y reglas distintas.

Por eso lo Ã³ptimo es:
ğŸ”µ Mercado Libre

ml_products
-----------
id
product_id
ml_item_id          // ID de ML
title
description
category_id_ml
price_ml
listing_type
status
variations (JSON)
attributes (JSON)
...

ğŸ”´ Google Merchant Center

google_products
---------------
id
product_id
google_product_id
google_title
google_description
google_category
google_price
google_sale_price
google_brand
condition
gtin
mpn
availability
feed_status
...

ğŸŸ£ Meta / Facebook Shop / Instagram

meta_products
-------------
id
product_id
meta_item_id
title
description
price
sale_price
category
availability
...

ğŸ¯ Â¿Por quÃ© usar tablas especÃ­ficas por canal?
âœ” 1) Cada canal exige campos diferentes

    Google obliga a: google_category, gtin, mpn

    Mercado Libre obliga a: attributes, listing_type, variations

    Meta tiene sus propias categorÃ­as
    Si metÃ©s todo en la tabla products â†’ se vuelve inmanejable.

âœ” 2) Cada canal tiene su propio ID

Ej:

    Mercado Libre â†’ item_id tipo "MLA123456789"

    Google â†’ g_product_id

    Meta â†’ fb_item_id

JamÃ¡s deben convivir en la tabla principal.
âœ” 3) Permite sincronizaciÃ³n independiente

PodÃ©s actualizar:

    stock en Mercado Libre

    precio en Google

    tÃ­tulo en Meta

Sin afectar la web principal.
âœ” 4) Evita recargar la tabla products con 200 columnas

Muchos ERP caen en este error.
Resultado: consultas lentas, cÃ³digo difÃ­cil de mantener y migraciones enormes.
âœ” 5) Optimiza el rendimiento para Eloquent

ConsultÃ¡s solo lo necesario:

Product::with('googleProduct', 'mlProduct', 'metaProduct')->find($id);

2â€“3 consultas limpias, sin columnas basura.
ğŸ§© 5) Relaciones Eloquent
Modelo Product

public function detail()
{
    return $this->hasOne(ProductDetail::class);
}

public function ml()
{
    return $this->hasOne(MlProduct::class);
}

public function google()
{
    return $this->hasOne(GoogleProduct::class);
}

public function meta()
{
    return $this->hasOne(MetaProduct::class);
}

public function attributes()
{
    return $this->hasMany(ProductAttributeValue::class);
}

ğŸš€ 6) Arquitectura final recomendada (muy usada en ERP grandes)

products
product_details
product_images
attributes
product_attribute_values

ml_products
google_products
meta_products

Si vendÃ©s en muchas plataformas mÃ¡s adelante (Amazon, Shopify, WooCommerce), solo agregÃ¡s:

amazon_products
shopify_products
etc...

Sin tocar nada del core.
ğŸ“Œ Si querÃ©s, te puedo armar (decime SÃ):
âœ” Migraciones completas
âœ” Modelos Eloquent completos
âœ” Seeders
âœ” Ejemplo de feed Google
âœ” Ejemplo de publicaciÃ³n Mercado Libre (API v2)
âœ” Ejemplo de sincronizaciÃ³n de stock multi-canal

Todo integrado para usar en tu e-commerce Laravel real.
----------------------------------------------------------------------------------------------------------------------

----------------------  TERCERO 3  ---------------------------------------------------------------------------
Lo rehago desde cero, ordenado, y dejando explÃ­cito el soporte multi-storage (multi-depÃ³sito / multi-sucursal) en TODAS las entidades donde corresponde.

Este modelo es nivel ERP, totalmente vÃ¡lido para e-commerce, marketplaces y operaciones reales.
ğŸ§  PRINCIPIO BASE (no negociable)

    Un producto puede existir en muchos storages

    Una venta puede salir de varios storages

    El stock NO se guarda en la venta

    El stock se mueve SOLO con movimientos

    El stock actual es un cÃ¡lculo / cache

ğŸ§± 1. PRODUCTS (producto)
products
Campo	Tipo	DescripciÃ³n
id	PK	
sku	string (unique)	CÃ³digo interno
name	string	Nombre
description	text	DescripciÃ³n corta
manage_stock	boolean	Si controla stock
type	enum	simple / variant / service
status	enum	active / inactive
created_at	timestamp	
updated_at	timestamp	

Relaciones

    hasMany â†’ stock_movements

    hasMany â†’ order_items

    hasMany â†’ purchase_items

    hasMany â†’ stock_levels

ğŸ§± 2. STORAGES (depÃ³sitos / sucursales / virtuales)
storages
Campo	Tipo	DescripciÃ³n
id	PK	
name	string	Nombre
code	string (unique)	WH01, ML_FULL
type	enum	warehouse / store / virtual
address	string	DirecciÃ³n
is_active	boolean	
created_at	timestamp	

Relaciones

    hasMany â†’ stock_movements

    hasMany â†’ order_items

    hasMany â†’ purchase_items

    hasMany â†’ stock_levels

ğŸ§± 3. STOCK LEVELS (stock actual por producto y storage)

âš ï¸ NO es la verdad
âœ” Es cache rÃ¡pido
stock_levels
Campo	Tipo
product_id	FK
storage_id	FK
quantity	integer
updated_at	timestamp

PK compuesta

(product_id, storage_id)

Relaciones

    belongsTo â†’ product

    belongsTo â†’ storage

ğŸ§± 4. STOCK MOVEMENTS (fuente de verdad)
stock_movements
Campo	Tipo	DescripciÃ³n
id	PK	
product_id	FK	
storage_id	FK	
quantity	integer	+ / -
movement_type	enum	IN / OUT / ADJUST / TRANSFER
source_type	enum	purchase / sale / return / transfer
source_id	bigint	id del documento
notes	text	
created_at	timestamp	

Relaciones

    belongsTo â†’ product

    belongsTo â†’ storage

ğŸ§± 5. SALES (ventas / pedidos)
orders
Campo	Tipo	DescripciÃ³n
id	PK	
user_id	FK	Cliente
status	enum	pending / paid / shipped / canceled
channel	enum	web / ml / google / meta
total	decimal	
created_at	timestamp	

Relaciones

    hasMany â†’ order_items

ğŸ§± 6. SALES ITEMS (Ã­tems de venta, MULTI-STORAGE)
order_items
Campo	Tipo	DescripciÃ³n
id	PK	
order_id	FK	
product_id	FK	
storage_id	FK	de dÃ³nde sale
quantity	integer	
price	decimal	
subtotal	decimal	
created_at	timestamp	

Relaciones

    belongsTo â†’ order

    belongsTo â†’ product

    belongsTo â†’ storage

ğŸ§± 7. PURCHASES (compras)
purchases
Campo	Tipo
id	PK
supplier_id	FK
status	enum (draft, received, canceled)
total	decimal
created_at	timestamp

Relaciones

    hasMany â†’ purchase_items

ğŸ§± 8. PURCHASE ITEMS (MULTI-STORAGE)
purchase_items
Campo	Tipo	DescripciÃ³n
id	PK	
purchase_id	FK	
product_id	FK	
storage_id	FK	a dÃ³nde entra
quantity	integer	
cost	decimal	
subtotal	decimal	

Relaciones

    belongsTo â†’ purchase

    belongsTo â†’ product

    belongsTo â†’ storage

ğŸ”— DIAGRAMA CONCEPTUAL RESUMIDO

Product
 â”œâ”€â”€ StockLevel (1 por storage)
 â”œâ”€â”€ StockMovement (historial)
 â”œâ”€â”€ OrderItem (salidas)
 â””â”€â”€ PurchaseItem (entradas)

Storage
 â”œâ”€â”€ StockLevel
 â”œâ”€â”€ StockMovement
 â”œâ”€â”€ OrderItem
 â””â”€â”€ PurchaseItem

Order
 â””â”€â”€ OrderItem (N productos, N storages)

Purchase
 â””â”€â”€ PurchaseItem (N productos, N storages)

ğŸ”„ FLUJOS CLAVES
ğŸŸ¢ Compra

Purchase
  â†’ PurchaseItem (storage X)
    â†’ StockMovement (+)
      â†’ StockLevel ++

ğŸ”´ Venta

Order
  â†’ OrderItem (storage Y)
    â†’ StockMovement (-)
      â†’ StockLevel --

ğŸ” Transferencia

OUT â†’ storage A
IN  â†’ storage B

ğŸ›¡ï¸ BENEFICIOS REALES

âœ… Multi-depÃ³sito real
âœ… Mercado Libre FULL / FBA / dropshipping
âœ… AuditorÃ­a completa
âœ… ReversiÃ³n segura
âœ… Escala sin romper el modelo
âœ… Compatible con colas, eventos y cache
ğŸ“Œ PrÃ³ximos pasos (si querÃ©s)

Puedo:

    ğŸ“„ Dibujarte el ERD visual

    âš™ï¸ Generarte migraciones Laravel

    ğŸ” Agregar reservas de stock

    ğŸ” Manejar devoluciones

    ğŸšš Integrar envÃ­os

    ğŸ‡¦ğŸ‡· Adaptarlo a AFIP / facturaciÃ³n argentina

Decime cÃ³mo querÃ©s seguir.
explicame como trabaja y como crear en Laravel StockLevel ya que dices que no es una tabla en la DB si no es virtual.

Excelente pregunta.
Esto es CLAVE para entender bien un sistema de stock profesional en Laravel.

Voy a explicarte cÃ³mo funciona realmente StockLevel, por quÃ© digo que es â€œvirtualâ€, y cÃ³mo implementarlo correctamente en Laravel, con dos enfoques (sin tabla y con tabla cache).
ğŸ§  1ï¸âƒ£ Â¿Por quÃ© StockLevel es â€œvirtualâ€?

Porque el stock REAL no se guarda.

ğŸ‘‰ La Ãºnica verdad es stock_movements.

El stock es simplemente:

STOCK = SUM(stock_movements.quantity)
        WHERE product_id = X
        AND storage_id = Y

Eso es un cÃ¡lculo, no un dato persistido.

Por eso decimos:

    StockLevel es una vista lÃ³gica, no una entidad de negocio.

ğŸ§± 2ï¸âƒ£ OpciÃ³n A â€” StockLevel SIN tabla (100% virtual)
ğŸ“Œ CuÃ¡ndo usarla

    CatÃ¡logo chico/mediano

    Menos de ~100k movimientos

    MÃ¡xima consistencia

    Reportes exactos

ğŸ”¹ Query base (SQL)

SELECT
  product_id,
  storage_id,
  SUM(quantity) AS stock
FROM stock_movements
GROUP BY product_id, storage_id;

ğŸ”¹ MÃ©todo Eloquent (recomendado)
Product.php

public function stockInStorage($storageId)
{
    return $this->stockMovements()
        ->where('storage_id', $storageId)
        ->sum('quantity');
}

Uso:

$stock = $product->stockInStorage($storageId);

âœ” No tabla
âœ” Siempre exacto
âŒ MÃ¡s costoso si se consulta mucho
ğŸ”¹ Stock total (todos los storages)

public function totalStock()
{
    return $this->stockMovements()->sum('quantity');
}

ğŸ§± 3ï¸âƒ£ OpciÃ³n B â€” StockLevel CON tabla (cache de stock)

ğŸ‘‰ Esta es la opciÃ³n usada en producciÃ³n real

âš ï¸ Sigue siendo â€œvirtualâ€ conceptualmente
âœ” Pero tiene tabla para performance
ğŸ“¦ Tabla stock_levels

stock_levels
------------
product_id
storage_id
quantity
updated_at

PRIMARY KEY (product_id, storage_id)

    â— Nunca se edita manualmente

ğŸ”¹ Modelo Eloquent
StockLevel.php

class StockLevel extends Model
{
    public $timestamps = false;
    protected $primaryKey = null;
    public $incrementing = false;

    protected $fillable = [
        'product_id',
        'storage_id',
        'quantity',
    ];
}

ğŸ”¹ RelaciÃ³n
Product.php

public function stockLevels()
{
    return $this->hasMany(StockLevel::class);
}

ğŸ”„ 4ï¸âƒ£ Â¿CÃ³mo se mantiene actualizado el stock?
âœ” Siempre a partir de stock_movements
ğŸ”¹ Flujo correcto

    InsertÃ¡s un movimiento

    ActualizÃ¡s el cache (stock_levels)

    Nunca al revÃ©s

ğŸ”¹ Servicio recomendado
StockService.php

class StockService
{
    public function move(
        int $productId,
        int $storageId,
        int $quantity,
        string $type,
        string $sourceType,
        int $sourceId
    ) {
        DB::transaction(function () use (
            $productId,
            $storageId,
            $quantity,
            $type,
            $sourceType,
            $sourceId
        ) {
            StockMovement::create([
                'product_id'   => $productId,
                'storage_id'   => $storageId,
                'quantity'     => $quantity,
                'movement_type'=> $type,
                'source_type'  => $sourceType,
                'source_id'    => $sourceId,
            ]);

            StockLevel::updateOrCreate(
                [
                    'product_id' => $productId,
                    'storage_id' => $storageId,
                ],
                [
                    'quantity' => DB::raw("quantity + {$quantity}")
                ]
            );
        });
    }
}

ğŸ›¡ï¸ 5ï¸âƒ£ Â¿QuÃ© pasa si se rompe el cache?

No pasa nada.
Rebuild total:

TRUNCATE stock_levels;

INSERT INTO stock_levels (product_id, storage_id, quantity)
SELECT product_id, storage_id, SUM(quantity)
FROM stock_movements
GROUP BY product_id, storage_id;

âœ” Cache reconstruido
âœ” Integridad intacta
âš–ï¸ 6ï¸âƒ£ ComparaciÃ³n real
Enfoque	Pros	Contras
100% virtual	Siempre exacto	Lento con mucho trÃ¡fico
Cache (recomendado)	Ultra rÃ¡pido	Requiere disciplina
ğŸ§  ConclusiÃ³n final

    StockLevel es virtual en concepto, no en implementaciÃ³n.

    La verdad â†’ stock_movements

    El rendimiento â†’ stock_levels

    Laravel â†’ ambos juntos

Esto es exactamente lo que usan:

    Shopify

    Odoo

    SAP

    VTEX

Si querÃ©s, el prÃ³ximo paso natural es:

    ğŸ” reservas de stock

    ğŸ” cancelaciones

    âš¡ eventos + colas

    ğŸ“¦ lotes / vencimientos
----------------------------------------------------------------------------------------------------------------------------

--------------------------------  CUARTO  4  ------------------------------------------------------------------------
ahora has un esquema de base dato y su relaciones. pero. entre supplier, client, user, cuenta corriente. Ten en cuenta que un client tambiÃ©n puede ser supplier y viceversa.

Excelente, este es un diseÃ±o de ERP real, bien pensado ğŸ‘
Vamos a armar un esquema de base de datos claro y extensible para:

    Users (usuarios del sistema)

    Persons (entidades comerciales)

    Clients

    Suppliers

    Cuenta corriente (ledger)

    Relaciones correctas cuando una misma entidad puede ser cliente y proveedor

La clave es NO duplicar personas.
ğŸ§  PRINCIPIO BASE (MUY IMPORTANTE)

    Cliente y proveedor NO son personas distintas, son ROLES comerciales.

La persona (empresa o individuo) es UNA
Puede actuar como:

    cliente

    proveedor

    ambos

ğŸ§± 1ï¸âƒ£ PERSONS (Entidad comercial Ãºnica)
persons

Representa una persona fÃ­sica o jurÃ­dica.
Campo	Tipo	DescripciÃ³n
id	PK	
type	enum	individual / company
name	string	RazÃ³n social / Nombre
document_type	enum	DNI / CUIT
document_number	string	
email	string	
phone	string	
address	text	
created_at	timestamp	

âœ” Una persona = una fila
âœ” Nunca duplicar
ğŸ§± 2ï¸âƒ£ USERS (usuarios del sistema)
users

Son los que usan el sistema, no los clientes.
Campo	Tipo
id	PK
person_id	FK (nullable)
email	string
password	string
status	enum
created_at	timestamp

RelaciÃ³n

    belongsTo â†’ person (opcional)

ğŸ“Œ Un usuario puede estar asociado a una persona (ej: dueÃ±o de la empresa)
ğŸ§± 3ï¸âƒ£ CLIENTS (rol comercial: cliente)
clients
Campo	Tipo
id	PK
person_id	FK (unique)
credit_limit	decimal
payment_terms	integer (dÃ­as)
active	boolean
created_at	timestamp

âœ” No duplica datos personales
ğŸ§± 4ï¸âƒ£ SUPPLIERS (rol comercial: proveedor)
suppliers
Campo	Tipo
id	PK
person_id	FK (unique)
payment_terms	integer
bank_account	string
active	boolean
created_at	timestamp

âœ” La misma persona puede estar en ambas tablas
ğŸ§± 5ï¸âƒ£ CURRENT ACCOUNTS (cuenta corriente)

    Una persona tiene UNA cuenta corriente
    No una por cliente / proveedor

current_accounts
Campo	Tipo
id	PK
person_id	FK (unique)
balance	decimal
created_at	timestamp

ğŸ“Œ balance puede ser cache
ğŸ“Œ La verdad estÃ¡ en los movimientos
ğŸ§± 6ï¸âƒ£ ACCOUNT MOVEMENTS (movimientos de cuenta corriente)
account_movements
Campo	Tipo	DescripciÃ³n
id	PK	
current_account_id	FK	
amount	decimal	+ / -
movement_type	enum	invoice / payment / credit_note / debit_note
source_type	enum	sale / purchase / payment
source_id	bigint	
created_at	timestamp	

âœ” + = nos debe
âœ” âˆ’ = le debemos / pagamos
ğŸ”— RELACIONES RESUMIDAS

Person
 â”œâ”€â”€ hasOne Client
 â”œâ”€â”€ hasOne Supplier
 â”œâ”€â”€ hasOne CurrentAccount
 â””â”€â”€ hasMany Users

User
 â””â”€â”€ belongsTo Person (opcional)

Client
 â””â”€â”€ belongsTo Person

Supplier
 â””â”€â”€ belongsTo Person

CurrentAccount
 â””â”€â”€ belongsTo Person
 â””â”€â”€ hasMany AccountMovement

ğŸ§  Â¿Por quÃ© este modelo es correcto?
âœ… No duplica datos

    No hay dos â€œJuan PÃ©rezâ€ distintos

âœ… Soporta cliente + proveedor

    Una empresa puede comprar y vender

âœ… Contabilidad limpia

    Una sola cuenta corriente por persona

âœ… Escalable

    PodÃ©s agregar mÃ¡s roles comerciales sin tocar persons

ğŸ§ª Ejemplo real

Empresa ACME S.A.:

    Compra insumos â†’ proveedor

    Revende productos â†’ cliente

persons: ACME S.A.
clients: person_id = 5
suppliers: person_id = 5
current_accounts: person_id = 5

Balance Ãºnico, movimientos claros.
ğŸ“Œ Extensiones tÃ­picas

Si querÃ©s ir un nivel mÃ¡s arriba:

    ğŸ“„ Facturas electrÃ³nicas (AFIP)

    ğŸ§¾ Retenciones / percepciones

    ğŸ¦ Bancos y conciliaciones

    ğŸ“Š Reportes contables

    ğŸ” Multi-empresa

Decime si querÃ©s que te arme:

    el ERD visual

    las migraciones Laravel

    o la lÃ³gica de cuenta corriente paso a paso

si por favor

Listo âœ…
Te dejÃ© todo el esquema completo en el canvas:

    ğŸ“ ERD claro (personas, clientes, proveedores, usuarios, cuenta corriente)

    ğŸ§± Listado de tablas con campos

    ğŸ› ï¸ Migraciones Laravel listas para usar

    ğŸ”„ LÃ³gica de cuenta corriente con transacciones

    ğŸ§  Reglas de negocio bien definidas

Este diseÃ±o es ERP-grade:

    sin duplicar personas

    soporta cliente/proveedor simultÃ¡neo

    consistente contablemente

    escalable a AFIP, multi-empresa, bancos, etc.

ğŸ‘‰ PrÃ³ximo paso recomendado (decime cuÃ¡l querÃ©s):

    Observer de AccountMovement para actualizar current_accounts.balance

    FacturaciÃ³n + impuestos (IVA, percepciones, retenciones)

    IntegraciÃ³n con ventas/compras y stock

    Tests automÃ¡ticos de cuenta corriente

    Multi-empresa (tenant)

Seguimos.
has solo estos pasos: Observer de AccountMovement para actualizar current_accounts.balance FacturaciÃ³n + impuestos (IVA, percepciones, retenciones) IntegraciÃ³n con ventas/compras y stock
Erp Personas, Clientes, Proveedores Y Cuenta Corriente
Esquema de Base de Datos y Relaciones
ERD (Diagrama Conceptual)
Person (persons)
â”œâ”€ hasOne â†’ Client (clients)
â”œâ”€ hasOne â†’ Supplier (suppliers)
â”œâ”€ hasOne â†’ CurrentAccount (current_accounts)
â””â”€ hasMany â†’ User (users)

User (users)
â””â”€ belongsTo â†’ Person

Client (clients)
â””â”€ belongsTo â†’ Person

Supplier (suppliers)
â””â”€ belongsTo â†’ Person

CurrentAccount (current_accounts)
â””â”€ belongsTo â†’ Person
â””â”€ hasMany â†’ AccountMovement (account_movements)

    Principio: Cliente y proveedor son roles de una misma entidad (persons). No se duplican datos.

Tablas y Campos
persons
Campo	Tipo
id	PK
type	enum(individual, company)
name	string
document_type	enum(DNI, CUIT)
document_number	string
email	string
phone	string
address	text
created_at	timestamp
updated_at	timestamp
users
Campo	Tipo
id	PK
person_id	FK nullable
email	string
password	string
status	enum
created_at	timestamp
updated_at	timestamp
clients
Campo	Tipo
id	PK
person_id	FK unique
credit_limit	decimal
payment_terms	integer
active	boolean
created_at	timestamp
updated_at	timestamp
suppliers
Campo	Tipo
id	PK
person_id	FK unique
payment_terms	integer
bank_account	string
active	boolean
created_at	timestamp
updated_at	timestamp
current_accounts
Campo	Tipo
id	PK
person_id	FK unique
balance	decimal (cache)
created_at	timestamp
updated_at	timestamp
account_movements
Campo	Tipo
id	PK
current_account_id	FK
amount	decimal (+/-)
movement_type	enum(invoice,payment,credit_note,debit_note)
source_type	enum(sale,purchase,payment)
source_id	bigint
created_at	timestamp
Migraciones (Laravel)
persons
Schema::create('persons', function (Blueprint $table) {
$table->id();
$table->enum('type', ['individual','company']);
$table->string('name');
$table->enum('document_type', ['DNI','CUIT']);
$table->string('document_number');
$table->string('email')->nullable();
$table->string('phone')->nullable();
$table->text('address')->nullable();
$table->timestamps();
});
users
Schema::create('users', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->nullable()->constrained()->nullOnDelete();
$table->string('email')->unique();
$table->string('password');
$table->enum('status', ['active','inactive']);
$table->timestamps();
});
clients
Schema::create('clients', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->decimal('credit_limit', 12, 2)->default(0);
$table->integer('payment_terms')->default(0);
$table->boolean('active')->default(true);
$table->timestamps();
});
suppliers
Schema::create('suppliers', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->integer('payment_terms')->default(0);
$table->string('bank_account')->nullable();
$table->boolean('active')->default(true);
$table->timestamps();
});
current_accounts
Schema::create('current_accounts', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->decimal('balance', 12, 2)->default(0);
$table->timestamps();
});
account_movements
Schema::create('account_movements', function (Blueprint $table) {
$table->id();
$table->foreignId('current_account_id')->constrained()->cascadeOnDelete();
$table->decimal('amount', 12, 2);
$table->enum('movement_type', ['invoice','payment','credit_note','debit_note']);
$table->enum('source_type', ['sale','purchase','payment']);
$table->unsignedBigInteger('source_id')->nullable();
$table->timestamps();
});
LÃ³gica de Cuenta Corriente (Flujo)
Regla

    La verdad estÃ¡ en account_movements

    current_accounts.balance es cache

Ejemplo: Factura de venta
DB::transaction(function () use ($personId, $amount, $orderId) {
$account = CurrentAccount::firstOrCreate(['person_id' => $personId]);

AccountMovement::create([
'current_account_id' => $account->id,
'amount' => $amount, // + nos debe
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $orderId,
]);
});
Ejemplo: Pago
DB::transaction(function () use ($personId, $amount, $paymentId) {
$account = CurrentAccount::where('person_id', $personId)->firstOrFail();

AccountMovement::create([
'current_account_id' => $account->id,
'amount' => -$amount, // pago
'movement_type' => 'payment',
'source_type' => 'payment',
'source_id' => $paymentId,
]);
});

    El balance se actualiza mediante Observer de AccountMovement de forma similar a stock_levels.

1ï¸âƒ£ Observer de AccountMovement â†’ actualizaciÃ³n automÃ¡tica de balance
Objetivo

Mantener current_accounts.balance como cache, sincronizado automÃ¡ticamente cada vez que se registra un movimiento contable.
Flujo
AccountMovement (verdad)
â†“ Observer
CurrentAccount.balance (cache)
Crear Observer
php artisan make:observer AccountMovementObserver --model=AccountMovement
AccountMovementObserver.php
class AccountMovementObserver
{
public function created(AccountMovement $movement)
{
CurrentAccount::where('id', $movement->current_account_id)
->update([
'balance' => DB::raw('balance + ' . $movement->amount),
'updated_at' => now(),
]);
}
}

âœ” Evita race conditions
âœ” Sin lÃ³gica en controladores
âœ” Transaccional
Registrar Observer
public function boot()
{
AccountMovement::observe(AccountMovementObserver::class);
}
2ï¸âƒ£ FacturaciÃ³n + Impuestos (IVA, percepciones, retenciones)
Tablas necesarias
invoices
Campo	DescripciÃ³n
id	PK
person_id	Cliente / Proveedor
type	sale / purchase
subtotal	Neto
tax_total	Impuestos
total	Total
status	draft / issued / paid
invoice_items
Campo	DescripciÃ³n
invoice_id	FK
product_id	FK
quantity	Cantidad
unit_price	Precio
vat_rate	% IVA
vat_amount	IVA
total	Total Ã­tem
tax_lines
Campo	DescripciÃ³n
invoice_id	FK
tax_type	IVA / perception / retention
rate	%
amount	Monto
Ejemplo cÃ¡lculo IVA
$vat = $net * 0.21;
$total = $net + $vat;
Impacto contable

Al emitir factura:
AccountMovement::create([
'current_account_id' => $account->id,
'amount' => $invoice->total, // cliente debe
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $invoice->id,
]);

Al registrar retenciÃ³n:
AccountMovement::create([
'current_account_id' => $account->id,
'amount' => -$retentionAmount,
'movement_type' => 'credit_note',
'source_type' => 'tax',
]);
3ï¸âƒ£ IntegraciÃ³n Ventas / Compras / Stock
Regla de oro

    Ventas y compras NO tocan stock ni balance directamente

Todo pasa por movimientos.
Venta (flujo completo)
Venta
â”œâ”€ Factura
â”‚ â””â”€ AccountMovement (+)
â””â”€ StockMovement (-)
DB::transaction(function () use ($sale) {

// 1. Stock
foreach ($sale->items as $item) {
StockMovement::create([
'product_id' => $item->product_id,
'storage_id' => $item->storage_id,
'quantity' => -$item->quantity,
'source_type' => 'sale',
'source_id' => $sale->id,
]);
}

// 2. Cuenta corriente
AccountMovement::create([
'current_account_id' => $sale->person->currentAccount->id,
'amount' => $sale->total,
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $sale->id,
]);
});
Compra
Compra
â”œâ”€ Factura proveedor
â”‚ â””â”€ AccountMovement (-)
â””â”€ StockMovement (+)
DB::transaction(function () use ($purchase) {

StockMovement::create([
'product_id' => $purchase->product_id,
'storage_id' => $purchase->storage_id,
'quantity' => +$purchase->quantity,
'source_type' => 'purchase',
'source_id' => $purchase->id,
]);

AccountMovement::create([
'current_account_id' => $purchase->supplier->currentAccount->id,
'amount' => -$purchase->total,
'movement_type' => 'invoice',
'source_type' => 'purchase',
'source_id' => $purchase->id,
]);
});
ğŸ§  ConclusiÃ³n

    AccountMovement = verdad contable

    StockMovement = verdad fÃ­sica

    Observers mantienen caches

    Transacciones garantizan consistencia

    DiseÃ±o ERP real y escalable

Perfecto âœ…
Ya dejÃ© solo esos tres puntos desarrollados al detalle en el canvas, sin ruido extra:

1ï¸âƒ£ Observer de AccountMovement

    actualizaciÃ³n automÃ¡tica y segura de current_accounts.balance

    sin race conditions

    integrado con transacciones

2ï¸âƒ£ FacturaciÃ³n + impuestos

    modelo correcto para IVA, percepciones y retenciones

    impacto contable real (no â€œmagiaâ€ en el balance)

    preparado para AFIP / LatinoamÃ©rica

3ï¸âƒ£ IntegraciÃ³n ventas, compras y stock

    flujo completo

    stock y contabilidad desacoplados

    movimientos como Ãºnica fuente de verdad

Este diseÃ±o:

    no se rompe con concurrencia

    permite auditorÃ­a

    escala a ERP serio

ğŸ‘‰ PrÃ³ximo paso lÃ³gico (si querÃ©s):

    reservas de stock

    pagos parciales

    conciliaciÃ³n bancaria

    multi-empresa / multi-tenant

    AFIP (CAE, tipos de comprobante)

Decime cÃ³mo seguimos.
si yo quiero hacer saber todos los movimientos de una Persons. los tengo que traer de accounts_movements, en current_accounts solo tengo el total.

SÃ­. Exactamente asÃ­ ğŸ‘
Tu razonamiento es correcto a nivel contable y de arquitectura.

Voy a explicÃ¡rtelo con precisiÃ³n, sin ambigÃ¼edades, y mostrarte cÃ³mo consultarlo bien en Laravel.
âœ… Respuesta corta (confirmaciÃ³n)

    âœ” Todos los movimientos de una Person se obtienen desde account_movements
    âœ” current_accounts solo guarda el balance total (cache)
    âœ” Nunca se usa current_accounts para auditorÃ­a o historial

ğŸ§  Por quÃ© esto es correcto (conceptualmente)
ğŸ“Œ account_movements = Libro mayor

    HistÃ³rico completo

    Inmutable

    Auditable

    Fuente de verdad

ğŸ“Œ current_accounts = Resumen

    Solo el saldo actual

    Se puede recalcular

    Optimiza performance

    Esto es exactamente como funciona contabilidad real y bancos.

ğŸ§± RelaciÃ³n correcta entre tablas

Person
 â””â”€â”€ hasOne CurrentAccount
        â””â”€â”€ hasMany AccountMovement

ğŸ” CÃ³mo obtener TODOS los movimientos de una Person
OpciÃ³n 1 â€” VÃ­a relaciones (recomendada)
Modelos

// Person.php
public function currentAccount()
{
    return $this->hasOne(CurrentAccount::class);
}

// CurrentAccount.php
public function movements()
{
    return $this->hasMany(AccountMovement::class);
}

Consulta

$movements = Person::find($personId)
    ->currentAccount
    ->movements()
    ->orderBy('created_at', 'desc')
    ->get();

âœ” Clara
âœ” SemÃ¡ntica
âœ” FÃ¡cil de mantener
OpciÃ³n 2 â€” Consulta directa (mÃ¡s eficiente para reportes)

$movements = AccountMovement::whereHas('currentAccount', function ($q) use ($personId) {
    $q->where('person_id', $personId);
})
->orderBy('created_at', 'desc')
->get();

âœ” Ideal para listados grandes
âœ” Evita cargar modelos innecesarios
ğŸ“Š Ejemplo de extracto de cuenta corriente

$movements = AccountMovement::whereHas('currentAccount', fn ($q) =>
    $q->where('person_id', $personId)
)->get();

$balance = CurrentAccount::where('person_id', $personId)->value('balance');

Esto replica exactamente un extracto bancario:

    movimientos

    saldo actual

ğŸ§ª Recalcular balance (prueba de integridad)

$realBalance = AccountMovement::whereHas('currentAccount', fn ($q) =>
    $q->where('person_id', $personId)
)->sum('amount');

PodÃ©s compararlo con:

$cachedBalance = $person->currentAccount->balance;

âœ” Si coinciden â†’ sistema sano
âœ” Si no â†’ tenÃ©s bug (y lo detectÃ¡s)
ğŸš« QuÃ© NO hacer (muy importante)

âŒ No guardes historial en current_accounts
âŒ No borres movimientos
âŒ No edites montos histÃ³ricos
âŒ No recalcules saldo en cada consulta
ğŸ›¡ï¸ Buenas prÃ¡cticas extra

    Ãndice en account_movements.current_account_id

    Ãndice en created_at

    Soft deletes âŒ (NO en contabilidad)

    Transacciones siempre

ğŸ§  ConclusiÃ³n final

âœ” SÃ­, todo el historial viene de account_movements
âœ” current_accounts es solo un resumen
âœ” Este diseÃ±o es el correcto y profesional

EstÃ¡s diseÃ±ando un sistema contable serio.

Si querÃ©s, seguimos con:

    extractos con saldo acumulado

    pagos parciales

    conciliaciÃ³n bancaria

    cierre de cuentas

    reportes contables

Decime.
pero esto no sobrecarga de trabajo account_movements y no tiene ningÃºn sentido tener acount_current

Muy buena pregunta.
Y es normal que aparezca esta duda: si uno no entiende el por quÃ©, parece redundante.
Vamos a aclararlo con criterio de sistemas reales (ERP / bancos / e-commerce grandes).

Voy por partes y con ejemplos concretos.
â“ Â¿No se sobrecarga account_movements?
ğŸ”´ NO.

account_movements DEBE crecer. Ese es su trabajo.

    Es el libro mayor.
    Los libros mayores nunca se borran ni se resumen.

Un ERP con 10 aÃ±os:

    millones de movimientos âœ”

    funciona perfectamente âœ”

Â¿Por quÃ©?

    EstÃ¡ indexada

    Se consulta por rangos

    Se usa solo cuando necesitÃ¡s historial

â“ Entoncesâ€¦ Â¿para quÃ© existe current_accounts?
ğŸ¯ current_accounts NO existe por lÃ³gica
ğŸ¯ existe por performance y concurrencia
ğŸ§  AnalogÃ­a REAL (banco)
Concepto	Banco
account_movements	Extracto histÃ³rico
current_accounts.balance	Saldo visible

Â¿El banco recalcula tu saldo sumando 10 aÃ±os de movimientos cada vez que abrÃ­s la app?

âŒ NO
âœ” Usa un saldo cacheado
ğŸ§® Â¿QuÃ© pasarÃ­a SIN current_accounts?

Cada vez que preguntÃ¡s:

    â€œÂ¿CuÃ¡nto debe este cliente?â€

Laravel tendrÃ­a que hacer:

SELECT SUM(amount)
FROM account_movements
WHERE current_account_id = 123;

En un sistema real:

    500k movimientos

    100 usuarios concurrentes

    dashboard con 20 saldos

ğŸ’£ Colapso innecesario
âš¡ Con current_accounts

SELECT balance
FROM current_accounts
WHERE person_id = 5;

âœ” O(1)
âœ” ultra rÃ¡pido
âœ” sin locks pesados
ğŸ§  Entoncesâ€¦ Â¿quÃ© tabla se consulta mÃ¡s?
Tabla	Uso
current_accounts	TODO el tiempo
account_movements	Cuando necesitÃ¡s detalle
ğŸ” Â¿Y la carga de escritura?

Cada factura / pago genera:

1 INSERT en account_movements
1 UPDATE en current_accounts

Eso es barato para cualquier BD.
ğŸ›¡ï¸ Consistencia garantizada

    Ambos dentro de DB::transaction

    Observer con DB::raw

    Sin inconsistencias

    Sin race conditions

â— Â¿CuÃ¡ndo NO usar current_accounts?

Solo en sistemas:

    muy chicos

    sin concurrencia

    sin crecimiento

    sin dashboards

Ejemplo:

    app escolar

    sistema interno chico

ğŸ§ª Prueba definitiva (integridad)

Si dudÃ¡s de current_accounts:

$real = AccountMovement::where('current_account_id', $id)->sum('amount');
$cache = CurrentAccount::find($id)->balance;

Si coinciden â†’ diseÃ±o correcto.
ğŸ§  ConclusiÃ³n clara

    âŒ No es redundante
    âŒ No es innecesario
    âŒ No sobrecarga

    âœ” Es la forma correcta y profesional

account_movements crece por diseÃ±o
current_accounts existe para performance
ğŸ§­ Regla de oro

    Nunca optimices lectura con lÃ³gica compleja.
    CacheÃ¡ resultados simples.

Si querÃ©s, el prÃ³ximo paso lÃ³gico es mostrarte:

    cÃ³mo paginar millones de movimientos

    cÃ³mo archivar movimientos viejos

    cÃ³mo hacer extractos con saldo acumulado

    cÃ³mo auditar diferencias automÃ¡ticamente
----------------------------------------------------------------------------------------------------------------------------

-----------------------------  QUINTO  5  ---------------------------------------------------------------------------
que tipo de documentos se crean y se reciben tanto para la compra y la venta, desde el afip o arca por ejemplo remito nota de credito. y como debo hacer la BD

Excelente pregunta. AcÃ¡ ya entramos en contabilidad + fiscalidad argentina real (AFIP / ARCA).
Te voy a explicar quÃ© documentos existen, cuÃ¡ndo se usan, quÃ© impactan (stock / cuenta corriente / impuestos) y cÃ³mo modelarlos en la base de datos sin que se rompa.

Voy en 3 capas:

    ğŸ“„ Documentos reales (compra / venta)

    ğŸ” QuÃ© impacto tiene cada uno

    ğŸ§± Modelo de BD recomendado (neutral, extensible)

1ï¸âƒ£ DOCUMENTOS EN ARGENTINA (AFIP / ARCA)
ğŸ”¹ DOCUMENTOS DE VENTA (emitidos)
ğŸ§¾ Factura

Tipos AFIP:

    Factura A

    Factura B

    Factura C

    Factura E

    Factura M

Impacta:

    âœ” Cuenta corriente (cliente debe)

    âœ” Impuestos (IVA, etc.)

    âŒ Stock (no directamente)

ğŸ§¾ Nota de crÃ©dito

Se usa para:

    devoluciÃ³n

    descuento posterior

    anulaciÃ³n parcial / total

Impacta:

    âœ” Cuenta corriente (reduce deuda)

    âœ” Impuestos (IVA negativo)

    âœ” Stock (si hay devoluciÃ³n fÃ­sica)

ğŸ§¾ Nota de dÃ©bito

Se usa para:

    intereses

    cargos adicionales

Impacta:

    âœ” Cuenta corriente (aumenta deuda)

    âœ” Impuestos

ğŸšš Remito

Documento logÃ­stico, NO fiscal.

Impacta:

    âœ” Stock

    âŒ Cuenta corriente

    âŒ Impuestos

    Un remito no genera deuda.

ğŸ”¹ DOCUMENTOS DE COMPRA (recibidos)
ğŸ§¾ Factura proveedor

Tipos:

    Factura A

    Factura B

    Factura C

Impacta:

    âœ” Cuenta corriente (vos debÃ©s)

    âœ” Impuestos (crÃ©dito fiscal IVA)

    âŒ Stock (no directamente)

ğŸ§¾ Nota de crÃ©dito proveedor

    devoluciÃ³n

    bonificaciÃ³n

Impacta:

    âœ” Cuenta corriente (reduce deuda)

    âœ” Impuestos

    âœ” Stock (si hay devoluciÃ³n)

ğŸšš Remito proveedor

Impacta:

    âœ” Stock

    âŒ Cuenta corriente

    âŒ Impuestos

2ï¸âƒ£ MATRIZ DE IMPACTO (CLAVE)
Documento	Stock	Cuenta Corriente	Impuestos
Factura venta	âŒ	âœ” +	âœ”
Nota crÃ©dito venta	âœ” (si dev.)	âœ” -	âœ”
Nota dÃ©bito venta	âŒ	âœ” +	âœ”
Remito venta	âœ” -	âŒ	âŒ
Factura compra	âŒ	âœ” -	âœ”
Nota crÃ©dito compra	âœ” +	âœ” +	âœ”
Remito compra	âœ” +	âŒ	âŒ
3ï¸âƒ£ MODELO DE BASE DE DATOS (CORRECTO)
ğŸ§  PRINCIPIO CLAVE

    El documento NO hace nada por sÃ­ mismo.
    El documento DISPARA movimientos.

ğŸ§± TABLA BASE: documents

documents
---------
id
person_id              -- cliente o proveedor
direction              -- sale / purchase
document_type           -- invoice, credit_note, debit_note, delivery_note
letter                  -- A, B, C, E, M
number
issue_date
subtotal
tax_total
total
status                  -- draft, issued, canceled
afip_cae
afip_cae_expiration
created_at

âœ” Unifica TODO
âœ” Compatible AFIP / ARCA
âœ” No duplica tablas
ğŸ§± document_items

document_items
--------------
document_id
product_id
quantity
unit_price
net_amount
vat_rate
vat_amount
total

ğŸ§± tax_lines (IVA, percepciones, retenciones)

tax_lines
---------
document_id
tax_type          -- vat, perception, retention
tax_code
rate
amount

ğŸ§± MOVIMIENTOS (los que ya definimos)
stock_movements

product_id
storage_id
quantity
source_type = document
source_id = documents.id

account_movements

current_account_id
amount
movement_type = invoice / credit_note / debit_note
source_type = document
source_id = documents.id

4ï¸âƒ£ FLUJOS REALES (EJEMPLOS)
ğŸ§¾ Emitir factura de venta

DB::transaction(function () use ($document) {

    // cuenta corriente
    AccountMovement::create([
        'current_account_id' => $document->person->currentAccount->id,
        'amount' => $document->total,
        'movement_type' => 'invoice',
        'source_type' => 'document',
        'source_id' => $document->id,
    ]);
});

ğŸšš Confirmar remito de venta

DB::transaction(function () use ($document) {

    foreach ($document->items as $item) {
        StockMovement::create([
            'product_id' => $item->product_id,
            'storage_id' => $item->storage_id,
            'quantity' => -$item->quantity,
            'source_type' => 'document',
            'source_id' => $document->id,
        ]);
    }
});

ğŸ§¾ Nota de crÃ©dito con devoluciÃ³n

DB::transaction(function () use ($document) {

    // stock
    foreach ($document->items as $item) {
        StockMovement::create([
            'product_id' => $item->product_id,
            'storage_id' => $item->storage_id,
            'quantity' => +$item->quantity,
            'source_type' => 'document',
            'source_id' => $document->id,
        ]);
    }

    // cuenta corriente
    AccountMovement::create([
        'current_account_id' => $document->person->currentAccount->id,
        'amount' => -$document->total,
        'movement_type' => 'credit_note',
        'source_type' => 'document',
        'source_id' => $document->id,
    ]);
});

ğŸ§  CONCLUSIÃ“N FINAL (IMPORTANTE)

âœ” AFIP / ARCA trabaja con documentos fiscales
âœ” Tu sistema trabaja con movimientos
âœ” El documento orquesta, no ejecuta
âœ” Este modelo:

    es auditable

    es escalable

    soporta AFIP real

    no se rompe con el tiempo

Si querÃ©s, el prÃ³ximo paso natural es:

    ğŸ“¡ integraciÃ³n AFIP (CAE)

    ğŸ“‘ tipos de comprobante AFIP y validaciones

    ğŸ”„ vincular remito â†’ factura

    ğŸ§¾ libros IVA ventas / compras

    ğŸ¦ conciliaciÃ³n bancaria AFIP

Decime y seguimos.
si por favor sigue

Perfecto, seguimos entonces ğŸ‘
Ahora voy a bajar esto a nivel AFIP real, sin humo, y cÃ³mo modelarlo bien en la BD para que despuÃ©s no tengas que reescribir todo.

Voy en este orden:

1ï¸âƒ£ Tipos de comprobantes AFIP (venta / compra)
2ï¸âƒ£ Estados reales del documento
3ï¸âƒ£ IntegraciÃ³n AFIP (CAE) â€“ flujo correcto
4ï¸âƒ£ RelaciÃ³n Remito â†’ Factura
5ï¸âƒ£ Libros IVA (ventas / compras)
6ï¸âƒ£ Ajustes finales al modelo de BD
1ï¸âƒ£ TIPOS DE COMPROBANTES AFIP (LOS QUE IMPORTAN)
ğŸ”¹ Ventas (emitidos)

AFIP identifica los comprobantes por cÃ³digo, no por nombre.
CÃ³digo AFIP	Documento
001	Factura A
006	Factura B
011	Factura C
003	Nota de CrÃ©dito A
008	Nota de CrÃ©dito B
013	Nota de CrÃ©dito C
002	Nota de DÃ©bito A
007	Nota de DÃ©bito B
012	Nota de DÃ©bito C
091	Remito (no fiscal)

ğŸ“Œ Remito no lleva CAE
ğŸ”¹ Compras (recibidos)

No pedÃ­s CAE, pero tenÃ©s que guardarlos para libros IVA.
Documento
Factura proveedor
Nota de crÃ©dito proveedor
Nota de dÃ©bito proveedor
Remito proveedor
2ï¸âƒ£ ESTADOS REALES DE UN DOCUMENTO

Esto es MUY importante y suele hacerse mal.
Estados correctos

draft        â†’ creado pero no vÃ¡lido
issued       â†’ emitido (CAE aprobado)
rejected     â†’ AFIP rechazÃ³
canceled     â†’ anulado internamente
accounted    â†’ impactÃ³ contabilidad

ğŸ“Œ Nunca borres documentos
ğŸ“Œ AFIP exige trazabilidad
3ï¸âƒ£ INTEGRACIÃ“N AFIP â€“ FLUJO CORRECTO
âŒ Error comÃºn

    Crear factura â†’ impactar stock â†’ impactar cuenta â†’ pedir CAE

âœ… Flujo correcto

1. Crear documento (draft)
2. Validar datos fiscales
3. Enviar a AFIP
4. AFIP devuelve CAE
5. Marcar como issued
6. ReciÃ©n ahÃ­ generar movimientos

Ejemplo real en cÃ³digo

DB::transaction(function () use ($document) {

    // 1. Pedir CAE (fuera o dentro segÃºn diseÃ±o)
    $cae = AfipService::emitInvoice($document);

    if (!$cae->approved) {
        throw new Exception('AFIP rechazÃ³ el comprobante');
    }

    // 2. Guardar datos AFIP
    $document->update([
        'status' => 'issued',
        'afip_cae' => $cae->code,
        'afip_cae_expiration' => $cae->expiration,
    ]);

    // 3. Impacto contable
    AccountMovement::create([
        'current_account_id' => $document->person->currentAccount->id,
        'amount' => $document->total,
        'movement_type' => 'invoice',
        'source_type' => 'document',
        'source_id' => $document->id,
    ]);
});

âœ” Si AFIP falla â†’ no hay movimientos
âœ” Nunca hay deuda sin factura vÃ¡lida
4ï¸âƒ£ REMITO â†’ FACTURA (RELACIÃ“N CLAVE)

En la vida real:

    entregÃ¡s mercaderÃ­a (remito)

    facturÃ¡s despuÃ©s

ğŸ“Œ Modelado correcto

documents
---------
id
parent_document_id   -- FK a remito
document_type

Ejemplo

Remito #123
  â””â”€â”€ Factura A #456

En BD

$invoice->parent_document_id = $deliveryNote->id;
$invoice->save();

ğŸ“Œ Esto permite:

    facturaciÃ³n parcial

    varios remitos â†’ una factura

    trazabilidad AFIP

5ï¸âƒ£ LIBROS IVA (VENTAS / COMPRAS)

AFIP exige exactamente estos datos.
Libro IVA Ventas

Se obtiene de:

    documents (issued)

    document_items

    tax_lines

Campos clave:

    CUIT cliente

    tipo comprobante

    punto de venta

    nÃºmero

    neto gravado

    IVA 21 / 10.5

    exento

    total

ğŸ‘‰ No necesitÃ¡s tablas nuevas, solo vistas / queries.
Libro IVA Compras

De:

    documentos de compra

    tax_lines

    datos del proveedor

Ejemplo consulta conceptual

SELECT
  d.issue_date,
  d.document_type,
  d.letter,
  d.number,
  p.document_number AS cuit,
  d.subtotal,
  SUM(t.amount) AS iva,
  d.total
FROM documents d
JOIN persons p ON p.id = d.person_id
LEFT JOIN tax_lines t ON t.document_id = d.id
WHERE d.direction = 'sale'
  AND d.status = 'issued';

6ï¸âƒ£ AJUSTES FINALES AL MODELO DE BD
documents (final)

documents
---------
id
person_id
direction           -- sale / purchase
document_type       -- invoice / credit_note / debit_note / delivery_note
afip_code
letter
point_of_sale
number
parent_document_id
issue_date
subtotal
tax_total
total
status
afip_cae
afip_cae_expiration
created_at

ğŸ§  CONCLUSIÃ“N FINAL (IMPORTANTE)

âœ” AFIP trabaja con documentos fiscales
âœ” Tu sistema trabaja con movimientos
âœ” El documento:

    valida

    registra

    vincula

    audita

âŒ El documento NO maneja stock ni dinero directamente

Este diseÃ±o:

    es correcto fiscalmente

    soporta AFIP real

    escala

    no se rompe

ğŸ”œ PrÃ³ximos pasos posibles

Decime cuÃ¡l querÃ©s y lo hacemos:

1ï¸âƒ£ Servicio AFIP (WSFEv1) paso a paso
2ï¸âƒ£ Tipos de IVA, percepciones y retenciones argentinas
3ï¸âƒ£ Pagos parciales y conciliaciÃ³n
4ï¸âƒ£ Multi-punto de venta
5ï¸âƒ£ FacturaciÃ³n electrÃ³nica + Mercado Libre

Seguimos.
has lo 5 pasos
Erp Personas, Clientes, Proveedores Y Cuenta Corriente
Esquema de Base de Datos y Relaciones
ERD (Diagrama Conceptual)
Person (persons)
â”œâ”€ hasOne â†’ Client (clients)
â”œâ”€ hasOne â†’ Supplier (suppliers)
â”œâ”€ hasOne â†’ CurrentAccount (current_accounts)
â””â”€ hasMany â†’ User (users)

User (users)
â””â”€ belongsTo â†’ Person

Client (clients)
â””â”€ belongsTo â†’ Person

Supplier (suppliers)
â””â”€ belongsTo â†’ Person

CurrentAccount (current_accounts)
â””â”€ belongsTo â†’ Person
â””â”€ hasMany â†’ AccountMovement (account_movements)

    Principio: Cliente y proveedor son roles de una misma entidad (persons). No se duplican datos.

Tablas y Campos
persons
Campo	Tipo
id	PK
type	enum(individual, company)
name	string
document_type	enum(DNI, CUIT)
document_number	string
email	string
phone	string
address	text
created_at	timestamp
updated_at	timestamp
users
Campo	Tipo
id	PK
person_id	FK nullable
email	string
password	string
status	enum
created_at	timestamp
updated_at	timestamp
clients
Campo	Tipo
id	PK
person_id	FK unique
credit_limit	decimal
payment_terms	integer
active	boolean
created_at	timestamp
updated_at	timestamp
suppliers
Campo	Tipo
id	PK
person_id	FK unique
payment_terms	integer
bank_account	string
active	boolean
created_at	timestamp
updated_at	timestamp
current_accounts
Campo	Tipo
id	PK
person_id	FK unique
balance	decimal (cache)
created_at	timestamp
updated_at	timestamp
account_movements
Campo	Tipo
id	PK
current_account_id	FK
amount	decimal (+/-)
movement_type	enum(invoice,payment,credit_note,debit_note)
source_type	enum(sale,purchase,payment)
source_id	bigint
created_at	timestamp
Migraciones (Laravel)
persons
Schema::create('persons', function (Blueprint $table) {
$table->id();
$table->enum('type', ['individual','company']);
$table->string('name');
$table->enum('document_type', ['DNI','CUIT']);
$table->string('document_number');
$table->string('email')->nullable();
$table->string('phone')->nullable();
$table->text('address')->nullable();
$table->timestamps();
});
users
Schema::create('users', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->nullable()->constrained()->nullOnDelete();
$table->string('email')->unique();
$table->string('password');
$table->enum('status', ['active','inactive']);
$table->timestamps();
});
clients
Schema::create('clients', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->decimal('credit_limit', 12, 2)->default(0);
$table->integer('payment_terms')->default(0);
$table->boolean('active')->default(true);
$table->timestamps();
});
suppliers
Schema::create('suppliers', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->integer('payment_terms')->default(0);
$table->string('bank_account')->nullable();
$table->boolean('active')->default(true);
$table->timestamps();
});
current_accounts
Schema::create('current_accounts', function (Blueprint $table) {
$table->id();
$table->foreignId('person_id')->unique()->constrained()->cascadeOnDelete();
$table->decimal('balance', 12, 2)->default(0);
$table->timestamps();
});
account_movements
Schema::create('account_movements', function (Blueprint $table) {
$table->id();
$table->foreignId('current_account_id')->constrained()->cascadeOnDelete();
$table->decimal('amount', 12, 2);
$table->enum('movement_type', ['invoice','payment','credit_note','debit_note']);
$table->enum('source_type', ['sale','purchase','payment']);
$table->unsignedBigInteger('source_id')->nullable();
$table->timestamps();
});
LÃ³gica de Cuenta Corriente (Flujo)
Regla

    La verdad estÃ¡ en account_movements

    current_accounts.balance es cache

Ejemplo: Factura de venta
DB::transaction(function () use ($personId, $amount, $orderId) {
$account = CurrentAccount::firstOrCreate(['person_id' => $personId]);

AccountMovement::create([
'current_account_id' => $account->id,
'amount' => $amount, // + nos debe
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $orderId,
]);
});
Ejemplo: Pago
DB::transaction(function () use ($personId, $amount, $paymentId) {
$account = CurrentAccount::where('person_id', $personId)->firstOrFail();

AccountMovement::create([
'current_account_id' => $account->id,
'amount' => -$amount, // pago
'movement_type' => 'payment',
'source_type' => 'payment',
'source_id' => $paymentId,
]);
});

    El balance se actualiza mediante Observer de AccountMovement de forma similar a stock_levels.

1ï¸âƒ£ Observer de AccountMovement â†’ actualizaciÃ³n automÃ¡tica de balance
Objetivo

Mantener current_accounts.balance como cache, sincronizado automÃ¡ticamente cada vez que se registra un movimiento contable.
Flujo
AccountMovement (verdad)
â†“ Observer
CurrentAccount.balance (cache)
Crear Observer
php artisan make:observer AccountMovementObserver --model=AccountMovement
AccountMovementObserver.php
class AccountMovementObserver
{
public function created(AccountMovement $movement)
{
CurrentAccount::where('id', $movement->current_account_id)
->update([
'balance' => DB::raw('balance + ' . $movement->amount),
'updated_at' => now(),
]);
}
}

âœ” Evita race conditions
âœ” Sin lÃ³gica en controladores
âœ” Transaccional
Registrar Observer
public function boot()
{
AccountMovement::observe(AccountMovementObserver::class);
}
2ï¸âƒ£ FacturaciÃ³n + Impuestos (IVA, percepciones, retenciones)
Tablas necesarias
invoices
Campo	DescripciÃ³n
id	PK
person_id	Cliente / Proveedor
type	sale / purchase
subtotal	Neto
tax_total	Impuestos
total	Total
status	draft / issued / paid
invoice_items
Campo	DescripciÃ³n
invoice_id	FK
product_id	FK
quantity	Cantidad
unit_price	Precio
vat_rate	% IVA
vat_amount	IVA
total	Total Ã­tem
tax_lines
Campo	DescripciÃ³n
invoice_id	FK
tax_type	IVA / perception / retention
rate	%
amount	Monto
Ejemplo cÃ¡lculo IVA
$vat = $net * 0.21;
$total = $net + $vat;
Impacto contable

Al emitir factura:
AccountMovement::create([
'current_account_id' => $account->id,
'amount' => $invoice->total, // cliente debe
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $invoice->id,
]);

Al registrar retenciÃ³n:
AccountMovement::create([
'current_account_id' => $account->id,
'amount' => -$retentionAmount,
'movement_type' => 'credit_note',
'source_type' => 'tax',
]);
3ï¸âƒ£ IntegraciÃ³n Ventas / Compras / Stock
Regla de oro

    Ventas y compras NO tocan stock ni balance directamente

Todo pasa por movimientos.
Venta (flujo completo)
Venta
â”œâ”€ Factura
â”‚ â””â”€ AccountMovement (+)
â””â”€ StockMovement (-)
DB::transaction(function () use ($sale) {

// 1. Stock
foreach ($sale->items as $item) {
StockMovement::create([
'product_id' => $item->product_id,
'storage_id' => $item->storage_id,
'quantity' => -$item->quantity,
'source_type' => 'sale',
'source_id' => $sale->id,
]);
}

// 2. Cuenta corriente
AccountMovement::create([
'current_account_id' => $sale->person->currentAccount->id,
'amount' => $sale->total,
'movement_type' => 'invoice',
'source_type' => 'sale',
'source_id' => $sale->id,
]);
});
Compra
Compra
â”œâ”€ Factura proveedor
â”‚ â””â”€ AccountMovement (-)
â””â”€ StockMovement (+)
DB::transaction(function () use ($purchase) {

StockMovement::create([
'product_id' => $purchase->product_id,
'storage_id' => $purchase->storage_id,
'quantity' => +$purchase->quantity,
'source_type' => 'purchase',
'source_id' => $purchase->id,
]);

AccountMovement::create([
'current_account_id' => $purchase->supplier->currentAccount->id,
'amount' => -$purchase->total,
'movement_type' => 'invoice',
'source_type' => 'purchase',
'source_id' => $purchase->id,
]);
});
ğŸ§  ConclusiÃ³n

    AccountMovement = verdad contable

    StockMovement = verdad fÃ­sica

    Observers mantienen caches

    Transacciones garantizan consistencia

    DiseÃ±o ERP real y escalable


ğŸ”œ ImplementaciÃ³n completa â€“ 5 PASOS
1ï¸âƒ£ Servicio AFIP (WSFEv1) â€“ Paso a paso
Componentes

    Certificado (.crt) y Clave privada (.key)

    Token & Sign (WSAA)

    WSFEv1 para emisiÃ³n

Flujo
Credenciales â†’ WSAA (token/sign)
â†’ WSFEv1 (FECAESolicitar)
â†’ CAE + vencimiento
Estructura de servicio
class AfipService
{
public function getTokenSign() { /* WSAA */ }
public function emitInvoice(Document $doc) { /* WSFEv1 */ }
}
Reglas

    Emitir solo si status=draft

    Guardar afip_code, point_of_sale, number, cae

    Si AFIP rechaza â†’ excepciÃ³n y rollback

2ï¸âƒ£ IVA, percepciones y retenciones (Argentina)
IVA (mÃ¡s comunes)

    21%

    10.5%

    27%

    Exento

tax_lines (uso)

    IVA por alÃ­cuota

    PercepciÃ³n IIBB

    RetenciÃ³n Ganancias / IVA

TaxLine::create([
'document_id' => $doc->id,
'tax_type' => 'vat',
'rate' => 21,
'amount' => $vatAmount,
]);

ğŸ“Œ AFIP exige desagregado por alÃ­cuota
3ï¸âƒ£ Pagos parciales y conciliaciÃ³n
payments
payments
--------
id
person_id
amount
method -- cash, transfer, card
reference
created_at
Impacto contable
AccountMovement::create([
'current_account_id' => $account->id,
'amount' => -$payment->amount,
'movement_type' => 'payment',
'source_type' => 'payment',
'source_id' => $payment->id,
]);

âœ” Soporta pagos parciales âœ” El saldo se mantiene correcto
4ï¸âƒ£ Multiâ€“punto de venta
points_of_sale
points_of_sale
--------------
id
number
name
active
documents

    point_of_sale

    NumeraciÃ³n independiente por PV

ğŸ“Œ AFIP numera por punto de venta
5ï¸âƒ£ FacturaciÃ³n electrÃ³nica + Mercado Libre
Modelo

    Orden ML â†’ Documento interno

    Documento interno â†’ AFIP

    Guardar IDs ML

documents
---------
external_channel -- mercadolibre\ nexternal_id
Flujo
Orden ML
â†’ Documento (draft)
â†’ AFIP (CAE)
â†’ Impacto contable
â†’ Sync estado ML

âœ” FacturÃ¡s desde tu sistema âœ” CumplÃ­s AFIP âœ” ConciliÃ¡s ventas ML
ğŸ§  Cierre

    Documentos orquestan

    Movimientos ejecutan

    AFIP valida

    Stock y contabilidad desacoplados

Este diseÃ±o es productivo, fiscal y escalable.

Listo âœ…
Ya implementÃ© los 5 pasos completos en el canvas, integrados con todo lo que venÃ­amos diseÃ±ando:

1ï¸âƒ£ Servicio AFIP (WSAA + WSFEv1)
2ï¸âƒ£ IVA, percepciones y retenciones (modelo correcto AFIP)
3ï¸âƒ£ Pagos parciales y conciliaciÃ³n contable
4ï¸âƒ£ Multi-punto de venta (numeraciÃ³n AFIP real)
5ï¸âƒ£ FacturaciÃ³n electrÃ³nica integrada con Mercado Libre

Con esto tenÃ©s:

    diseÃ±o fiscal correcto para Argentina

    contabilidad auditable

    stock desacoplado

    base sÃ³lida para e-commerce + ERP

ğŸ‘‰ PrÃ³ximos pasos posibles (cuando quieras):

    implementaciÃ³n real WSFEv1 en PHP

    validaciones AFIP por tipo de cliente (RI, MT, CF)

    notas de crÃ©dito automÃ¡ticas desde ML

    cierre mensual IVA

    multi-empresa (tenant)
------------------------------------------------------------------------------------------------------------------------------












































